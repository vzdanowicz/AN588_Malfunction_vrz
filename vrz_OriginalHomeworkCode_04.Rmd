---
title: "What's Your Malfunction?"
author: "Victoria Zdanowicz"
date: "10/19/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

[1] Write a simple R function, Z.prop.test(), that can perform one- or two-sample Z-tests for proportion data, using the following guidelines:

Your function should take the following arguments: p1 and n1 (no default) representing the estimated proportion and sample size (i.e., based on your sample data); p2 and n2 (both defaulting to NULL) that contain a second sample’s proportion and sample size data in the event of a two-sample test; p0 (no default) as the expected value for the population proportion; and alternative (default “two.sided”) and conf.level (default 0.95), to be used in the same way as in the function t.test().

z = (observed statistic - expected statistic) / standard error

my.func <- function(arg1, arg2, arg3, ...) {
<commands>
return(output.object)
}

z.prop.test() <- function(p1, n1, p2=NULL, n2=NULL, p0, alternative = "two.sided", conf.level=0.95)
p1<- sum(v1)/n1
n1 <- length(v1)
p2 <- mean(v2)
n2 <- length(v2)
p0 = pi (expected proportion)

z1 <- (p1 - p0)/sqrt(1 - p0)/n1

pval <- 1 - pnorm(z1, lower.tail = TRUE) + pnorm(z1, lower.tail = FALSE)
pval

if(!is.numeric(c(a1, r, n))) return("The parameters must be numbers")

if p2 and/or n2 = NULL -> one-sample z test

z = (p-p0) / √p0(1-p0)/n

how to calculate CI for 2 sample? only see it from prop.test not written out in module

#My function?

```{r - function}
z.prop.test <- function(p1, n1, p2 = NULL, n2 = NULL, p0, alternative = "two-sided", conf.level = 0.95) 
{

  if (is.null(p2)|is.null(n2)) {
      Z <- (p1 - p0) / sqrt(p0 * (1-p0)/n1)
      PVAL <- 1 - pnorm(Z, lower.tail = TRUE) + pnorm(z, lower.tail = FALSE)
        if ((n1 * p0 < 5) | (n1 * (1 - p0) < 5 ))
        return(warning("check distribution, does not appear normal"))
          lower <- p1 - qnorm(0.975) * sqrt(p1 * (1 - p1)/n1)
          upper <- p1 + qnorm(0.975) * sqrt(p1 * (1 - p1)/n1)
          ci <- c(lower, upper)
          one.sample.prop <- list(z.test.statistic = as.numeric(Z), p.value = as.numeric(PVAL), conf.level = ci)
          
          return(one.sample.prop)
  }
  
  else  {
      pstar <- (p1 + p2)/(n1 + n2)
      Z <- (p2 - p1)/sqrt((pstar * (1 - pstar)) * (1/n1) + (1/n2))
      PVAL <- 1 - pnorm(Z, lower.tail = TRUE) + pnorm(Z, lower.tail = FALSE)
          if ((n1 * p0 < 5) | (n1 * (1 - p0) < 5 ) | (n2 * p0 < 5) | (n2 * (1 - p0) < 5)){
          warning("check distribution, does not appear normal")
}
            alpha = 1 - (conf.level/100)
            crit <- qnorm(1 - alpha/2)  # identify critical values
            test <- p < -crit || p > crit  # boolean test
            two.sample.prop <- list(z.test.statistic = as.numeric(Z), p.value = as.numeric(PVAL), conf.level = conf.level, critical.value = as.numeric(crit), test = test)
            
            return(two.sample.prop)
}}
```

test this function with sample data from module?
p1 = 0.6
n1 = 30L

```{r - one sample test?}
z.prop.test(0.6, 30, p0 = 0.8, alternative = "two-sided", conf.level = 0.95)

```

test this function with sample data from module?
p1 = phat1
n1 = 25
p2 = phat2
n2 = 30

```{r - two sample test?}
z.prop.test(0.56, 25, 0.7, 30, p0 = 0, alternative = "two-sided", conf.level = 0.95)

```


```{r - brain dumping !!!!}
function (p1, n1, p2 = NULL, n2 = NULL, p0, alternative = "two-sided", conf.level = 0.95) 

  
  
  if (is.null(p2)|is.null(n2)) {
    Z <- (p1 - p0) / sqrt(p0 * (1-p0)/n1)
    PVAL <- 1 - pnorm(Z, lower.tail = TRUE) + pnorm(z, lower.tail = FALSE)
  
      lower <- p1 - qnorm(0.975) * sqrt(p1 * (1 - p1)/n1)
      upper <- p1 + qnorm(0.975) * sqrt(p1 * (1 - p1)/n1)
      ci <- c(lower, upper)
      one.sample.prop <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = as.numeric(PVAL), 
                         conf.int = ci, alternative = alternative, method = METHOD)
      return(one.sample.prop)
  }
else {
  pstar <- (p1 + p2)/(n1 + n2)
  Z <- (p2 - p1)/sqrt((pstar * (1 - pstar)) * (1/length()))
  PVAL <- 1 - pnorm(Z, lower.tail = TRUE) + pnorm(Z, lower.tail = FALSE)
  crit <- qnorm(1 - alpha/2)  # identify critical values
  test <- p < -crit || p > crit  # boolean test
  test
}

p0 <- p0[OK]
if (any((p0 <= 0) | (p0 >= 1))) 
  stop("elements of 'p0' must be in (0,1)")


  PARAMETER <- k - 1
}
else {
  PARAMETER <- k
  names(NVAL) <- names(ESTIMATE)
}
names(PARAMETER) <- "df"
x <- cbind(x, n - x)
E <- cbind(n * p, n * (1 - p))
if (any(E < 5)) 
  warning("Chi-squared approximation may be incorrect")
STATISTIC <- sum((abs(x - E) - YATES)^2/E)
names(STATISTIC) <- "X-squared"
if (alternative == "two.sided") 
  PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
else {
  if (k == 1) 
    z <- sign(ESTIMATE - p) * sqrt(STATISTIC)
  else z <- sign(DELTA) * sqrt(STATISTIC)
  PVAL <- pnorm(z, lower.tail = (alternative == "less"))
}
RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
             p.value = as.numeric(PVAL), estimate = ESTIMATE, null.value = NVAL, 
             conf.int = CINT, alternative = alternative, method = METHOD, 
             data.name = DNAME)
class(RVAL) <- "htest"
return(RVAL)
}
```
